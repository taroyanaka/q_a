<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vue_3_starter</title>
    <link rel="stylesheet" href="./lib/reset.css">
<script src="./lib/vue@3.2.36.global.prod.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.36/vue.cjs.js"></script> -->
</head>
<body class="app">
    <button @click="fetch_hello">fetch_hello</button>
    <!-- this.nameのinput:text -->
    <input type="text" v-model="name" placeholder="name">
    <!-- this.passwordのinput -->
    <input type="password" v-model="password" placeholder="password">
    <!-- this.linkのinput -->
    <input type="url" v-model="link" placeholder="link">
    <!-- fetch_insert_linkを実行するボタン -->
    <button @click="fetch_insert_link">fetch_insert_link</button>
    <button @click="fetch_test_db_init">fetch_test_db_init</button>



<div v-if="web_data['message']">


<ul>
    <li v-for="(DATA_VAL, DATA_IDX) in web_data['message']">
        <div>{{ DATA_VAL['id'] }}</div>
        <div>{{ DATA_VAL['name'] }}</div>
        <div>{{ DATA_VAL['link'] }}</div>
        <div>{{ DATA_VAL['like'] }}</div>
        <div>{{ DATA_VAL['created_at'] }}</div>
        <div>{{ DATA_VAL['updated_at'] }}</div>

                <input type="text" v-model="comment" placeholder="comment">
                <button @click="fetch_insert_comment(DATA_VAL['id'])">fetch_insert_comment</button>


                <!-- {{ DATA_VAL['comments_and_replies'] }} -->

                            <ul>
                            <li v-for="(COMMENT_AND_REPLIES, COMMENT_IDX) in DATA_VAL['comments_and_replies']">
                id: {{ COMMENT_AND_REPLIES[COMMENT_IDX]['id'] }}
                comment: {{ COMMENT_AND_REPLIES[COMMENT_IDX]['comment'] }}
                                <button @click="fetch_delete_comment(
                                    COMMENT_AND_REPLIES[COMMENT_IDX]['id']
                                )">fetch_delete_comment</button>

                    <input type="text" v-model="comment_reply" placeholder="comment_reply">
                <button @click="fetch_insert_comment_reply(COMMENT_AND_REPLIES[COMMENT_IDX]['id'])">fetch_insert_comment_reply</button>        

                                    <ul>
                                    <li v-for="(REPLIES, REPLIES_PROP) in COMMENT_AND_REPLIES['comment_replies'] ">
                id: {{ REPLIES['id'] }}
                reply: {{ REPLIES['reply'] }}
                username: {{ REPLIES['username'] }}
                                        <button @click="fetch_delete_comment_reply(
                                            REPLIES['id']
                                        )">fetch_delete_comment_reply</button>
                                    </li>
                                    </ul>
                            </li>
                            </ul>

<span v-for="(like, like_i) in DATA_VAL['likes']">
    {{ '❤️' }}
</span>
<button @click="fetch_like_increment_or_decrement(DATA_VAL['id'])">fetch_like_increment_or_decrement</button>


        <div>{{ DATA_VAL['tag'] }}</div>
        <div>{{ DATA_VAL['tag_id'] }}</div>

        <button @click="fetch_delete_link(DATA_VAL['id'])">fetch_delete_link</button>

        <!-- 上記には以下のボタンが必要 -->
        <!-- fetch_like_increment_or_decrement -->

        <!-- fetch_insert_comment -->
        <!-- fetch_delete_comment -->
        <!-- <button @click="fetch_delete_comment(DATA_VAL['comment_id'])">fetch_delete_comment</button> -->
        <!-- fetch_insert_comment_reply -->

        <!-- fetch_insert_tag -->
        <input type="text" v-model="tag" placeholder="tag">
        <button @click="fetch_insert_tag(DATA_VAL['id'])">fetch_insert_tag</button>
        <!-- fetch_get_tags_for_autocomplete -->
        <button @click="fetch_get_tags_for_autocomplete">fetch_get_tags_for_autocomplete</button>
        <!-- fetch_delete_tag -->
        <button @click="fetch_delete_tag(DATA_VAL['id'], DATA_VAL['tag_id'])">fetch_delete_tag</button>
    </li>
</ul>

</div>


    <h1>duct</h1>
    <h2> :ja ductはlink共有とlinkへのコメントをするwebサービスです </h2>
    <h2> :en duct is a web service that allows you to share links and comment on them. </h2>

<!-- <button @click="fn_0">fn_0</button>
<template v-for="(DATA_VAL, DATA_IDX) in data_1">
<div>{{ DATA_VAL }}</div>
</template>
<textarea name="" id="" cols="30" rows="10" v-model="data_0"></textarea> -->
</body>
<script>
const app = Vue.createApp({
data() {
    return {
name: 'user1',
password: 'user_pass1',
web_data: {},
link: 'https://yanaka.dev/',
tag: 'tag1',
comment: 'comment1',
comment_reply: 'comRep',
data: null,
    }},
watch: {
//    any: {
//      handler() {
//      },
//      deep: true
//    },
},
beforeMounte(){
},
mounted() {
    // this.fetch_hello_world();
    this.fetch_read_all();
},
beforeUpdate() {
},
updated() {
},
methods: {


async fetch_test_db_init(){
    const res = await fetch('http://localhost:8000' + '/test_db_init', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link: this.link, test_mode: 'TEST_MODE' }),
    });
    const data = await res.json(); console.log(data);
},

// read_allをfetchする関数
async fetch_hello(){
    // const res = await fetch('http://localhost:8000' + '/test', {method: 'POST',headers: {'Content-Type': 'application/json',},
    // const res = await fetch('http://localhost:8000/', {method: 'POST',headers: {'Content-Type': 'application/json',},
    //     body: JSON.stringify({ name: this.name, password: this.password, link: this.link }),
    // });
    // const data = await res.json(); console.log(data);
    const res = await fetch('http://localhost:8000' + '/', {method: 'GET', headers: {'Content-Type': 'application/json',},});
    const hello_data = await res.json();
    console.log(hello_data);
},


// read_allをfetchする関数
async fetch_read_all(){
    const res = await fetch('http://localhost:8000' + '/read_all', {method: 'GET', headers: {'Content-Type': 'application/json',},});
    this.web_data = await res.json(); console.log(this.web_data);
    // const sample = await res.json(); console.log(sample);
},

async fetch_insert_link(){
    const res = await fetch('http://localhost:8000' + '/insert_link', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link: this.link }),
    });
    const data = await res.json(); console.log(data);
},

async fetch_delete_link(LINK_ID){
    const res = await fetch('http://localhost:8000' + '/delete_link', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, id: LINK_ID }),
    });
    const data = await res.json(); console.log(data);
},

// app.post('/like_increment_or_decrement', (req, res) => {
async fetch_like_increment_or_decrement(LINK_ID){
    // console.log(LINK_ID);
    const res = await fetch('http://localhost:8000' + '/like_increment_or_decrement', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link_id: LINK_ID }),
    });
    const data = await res.json(); console.log(data);
},

// app.post('/insert_comment', (req, res) => {
    // this.comment
async fetch_insert_comment(LINK_ID){
    const res = await fetch('http://localhost:8000' + '/insert_comment', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link_id: LINK_ID, comment: this.comment }),
    });
    const data = await res.json(); console.log(data);
},

// app.post('/delete_comment', (req, res) => {
    // this.comment
async fetch_delete_comment(COMMENT_ID){
    console.log(COMMENT_ID);
    const res = await fetch('http://localhost:8000' + '/delete_comment', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, comment_id: COMMENT_ID }),
    });
    const data = await res.json(); console.log(data);
},

// app.post('/insert_comment_reply', (req, res) => {
    // this.comment_reply
async fetch_insert_comment_reply(COMMENT_ID){
    console.log(COMMENT_ID);
    const res = await fetch('http://localhost:8000' + '/insert_comment_reply', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, comment_id: COMMENT_ID, comment_reply: this.comment_reply }),
    });
    const data = await res.json(); console.log(data);
},


// app.post('/delete_comment_reply', (req, res) => {
async fetch_delete_comment_reply(COMMENT_REPLY_ID){
    const res = await fetch('http://localhost:8000' + '/delete_comment_reply', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, comment_reply_id: COMMENT_REPLY_ID }),
    });
    this.data = await res.json(); console.log(this.data);
},

// app.post('/insert_tag', (req, res) => {
    // this.tag
async fetch_insert_tag(LINK_ID){
    const res = await fetch('http://localhost:8000' + '/insert_tag', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link_id: LINK_ID, tag: this.tag }),
    });
    const data = await res.json(); console.log(data);
},

// app.post('/get_tags_for_autocomplete', (req, res) => {
    // this.tag
async fetch_get_tags_for_autocomplete(){
    const res = await fetch('http://localhost:8000' + '/get_tags_for_autocomplete', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, tag: this.tag }),
    });
    const data = await res.json(); console.log(data);
},

// delete_tagはペンディング
// // app.post('/delete_tag', (req, res) => {
    

async fetch_insert_tag(LINK_ID, TAG){
    const res = await fetch('http://localhost:8000' + '/insert_tag', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link_id: LINK_ID, tag: this.tag }),
    });
    const data = await res.json(); console.log(data);
},

async fetch_delete_tag(LINK_ID, TAG_ID){
    const res = await fetch('http://localhost:8000' + '/delete_tag', {method: 'POST',headers: {'Content-Type': 'application/json',},
        body: JSON.stringify({ name: this.name, password: this.password, link_id: LINK_ID, id: TAG_ID }),
    });
    const data = await res.json(); console.log(data);
},

all_error_check(){
    const error_check_for_insert_comment = (comment, DATA_LIMIT) => {
        const reserved_words = ['SELECT', 'FROM', 'WHERE', 'INSERT', 'DELETE', 'UPDATE', 'DROP', 'ALTER', 'CREATE', 'TABLE', 'INTO', 'VALUES', 'AND', 'OR', 'NOT', 'NULL', 'TRUE', 'FALSE'];
        switch (true) {
            case comment === undefined: return {res: 'commentが空の場合はエラー', status: false};
            case comment.length > DATA_LIMIT: return {res: 'commentの文字数がdata_limitを超える場合はエラー', status: false};
            case comment.length === 0: return {res: '0文字の場合はエラー', status: false};
            case comment.match(/[!-/:-@[-`{-~]/g): return {res: '記号を含む場合はエラー', status: false};
            case comment.match(/\s/g): return {res: '空白を含む場合はエラー', status: false};
            case comment.length > 300: return {res: '300文字以上はエラー', status: false};
            case reserved_words.includes(comment): return {res: 'SQLの予約語を含む場合はエラー', status: false};
            default: return {res: 'OK', status: true};
        }
    }
    const error_check_for_insert_comment_reply = (comment_reply, DATA_LIMIT) => {
        const reserved_words = ['SELECT', 'FROM', 'WHERE', 'INSERT', 'DELETE', 'UPDATE', 'DROP', 'ALTER', 'CREATE', 'TABLE', 'INTO', 'VALUES', 'AND', 'OR', 'NOT', 'NULL', 'TRUE', 'FALSE'];
        switch (true) {
            case comment_reply === undefined: return {res: 'comment_replyが空の場合はエラー', status: false};
            case comment_reply.length > DATA_LIMIT: return {res: 'comment_replyの文字数がdata_limitを超える場合はエラー', status: false};
            case comment_reply.length === 0: return {res: '0文字の場合はエラー', status: false};
            case comment_reply.match(/[!-/:-@[-`{-~]/g): return {res: '記号を含む場合はエラー', status: false};
            case comment_reply.match(/\s/g): return {res: '空白を含む場合はエラー', status: false};
            case comment_reply.length > 10: return {res: '10文字以上はエラー', status: false};
            case reserved_words.includes(comment_reply): return {res: 'SQLの予約語を含む場合はエラー', status: false};
            default: return {res: 'OK', status: true};
        }
    }
    const error_check_for_insert_tag = (tag) => {
        const reserved_words = ['SELECT', 'FROM', 'WHERE', 'INSERT', 'DELETE', 'UPDATE', 'DROP', 'ALTER', 'CREATE', 'TABLE', 'INTO', 'VALUES', 'AND', 'OR', 'NOT', 'NULL', 'TRUE', 'FALSE'];
        switch (true) {
            case tag === undefined: return {res: 'tagが空です', status: false};
            case tag.match(/[!-/:-@[-`{-~]/g): return {res: '記号を含む場合はエラー', status: false};
            case tag.match(/\s/g): return {res: '空白を含む場合はエラー', status: false};
            case tag.length > 7: return {res: '7文字以上はエラー', status: false};
            case reserved_words.includes(tag): return {res: 'SQLの予約語を含む場合はエラー', status: false};
            default: return {res: 'OK', status: true};
        }
    }
},

},
}).mount('.app');
</script>
</html>
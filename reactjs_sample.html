<!DOCTYPE html>
<html>
<head>
<!-- <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script> -->
<script src="lib/react.production.min.js"></script>
<!-- <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script> -->
<script src="lib/react-dom.production.min.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.2/babel.js" integrity="sha512-H4d7o4neCJ2oxn87hZ28u2Xe+cMjt09Tb9TL9d4IckR0cda69w7sJpdkh6+oJveViuueEBlBxevEtpw3++Cz7w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->
<script src="lib/babel.min.js"></script>

<script src="lib/ramda.@0.28.0.js"></script>

<script src="lib/shuffle.js"></script>

</head>
<body>
<div class="react_app"></div>
<script type="text/babel">

let data0, data1 , data2, data3, data4, data5, data6, data7, data8, data9;
data0, data1 = data2 = data3 = data4 = data5 = data6 = data7 = data8 = data9 = null;

function Neko1() {
    const for_debug = (data_ary) => {
    data0 = data_ary[0];
    data1 = data_ary[1];
    data2 = data_ary[2];
    data3 = data_ary[3];
    data4 = data_ary[4];
    // data5 = data_ary[5];
    // data6 = data_ary[6];
    // data7 = data_ary[7];
    // data8 = data_ary[8];
    // console.log(data1 , data2, data3, data4, data5, data6, data7, data8, data9);
    // console.log(data_ary);
    };



    const [val2_1, setVal2_1] = React.useState(`foo
qux
日本
blabla
brabra
bowbow`);
    const two_way_bind_val2_1 = (event) => setVal2_1(event.target.value);
    const val2_2 = val2_1.split("\n");
    const [val3_1, setVal3_1] = React.useState(`foo bar baz
or foo2barQUXqux42ba😄abc😄z3isfoo2bar2baz3
日本語は自然言語のうちの一つで主に日本国内で使われています`);
    const two_way_bind_val3_1 = (event) => setVal3_1(event.target.value);

    const [val4_1, setVal4_1] = React.useState([]);
    const two_way_bind_val4_1 = (event) => setVal4_1(event.target.value);


const fn2_1 = (target_str, replacer_str) => {
    const fn2_1_tmp1 = target_str.split(new RegExp(replacer_str));
    const fn2_1_tmp2 = R.intersperse([replacer_str], fn2_1_tmp1);
    return fn2_1_tmp2;
};
const removeIndex0 = (ary) => R.remove(0, 1, ary);
// fn3は、replacer_str_ary.lengthが0になるまでtarget_strを[replacer_str]で分割し、全ての要素を文字列から配列に変形したRESULT_ARRAY配列を完成させるまで、再帰的に関数を適用する
const fn3 = (target_str, replacer_str_ary) =>{
    let RESULT_ARRAY = [];
    const fn2 = (target_str, replacer_str_ary) => {
        if (replacer_str_ary.length <= 0) {
            return target_str;
        } else {
            // 文字列の場合にのみ関数を適用し、文字列でなければそのまま返す
            const result = (typeof target_str === 'string') ? fn2_1(target_str, replacer_str_ary[0]) : target_str;
            replacer_str_ary = removeIndex0(replacer_str_ary);
            // 再帰
            let res = result.map(V=>fn2(V, replacer_str_ary));
            res.includes(undefined) === false ? RESULT_ARRAY.push(res) : null;
        }
    };
    fn2(target_str, replacer_str_ary);
    return RESULT_ARRAY;
};


const remove_any_elelemnt_from_ary_one_liner = (ary, val) => ary.filter(V=> V !== val);
const f_i_b_composer = (ARG_ARY) => {
// console.log(remove_any_elelemnt_from_ary_one_liner(ARG_ARY, 'foo'));

    return ARG_ARY.reduce((ACC, VAL) => {
        const DATA_X = R.insert(0, '', shuffle(shuffle(remove_any_elelemnt_from_ary_one_liner(ARG_ARY, VAL)).slice(0, 2).concat(VAL)));
        const DATA_Y = [VAL, DATA_X, false];
        ACC.push(DATA_Y);
        return ACC;
        },
        []
    );
    //     const DATA_X = R.insert(0, '', shuffle(shuffle(remove_any_elelemnt_from_ary_one_liner(ARG_ARY, ARG_VAL)).slice(0, 2).concat(ARG_VAL)));
    //     const DATA_Y = [ARG_VAL, DATA_X, false];
    // return DATA_Y;

    // return [FROM_ARY]
};

let data_any = f_i_b_composer(val2_2);


const fn4 = (ARY) => R.flatten(ARY).map(V=>val2_2.includes(V) ? data_any.filter(VAL=>VAL[0]===V)[0] : V);
const remove_empty_string = (ary) => ary.filter(V=> V !== "");


const execute = () => {
    const tmp1 = fn3(val3_1, val2_2);
    const tmp2 = fn4(tmp1);
    const tmp3 = remove_empty_string(tmp2);
    // setVal4_1(f_i_b_composer(val2_2));
    for_debug([tmp1, tmp2, tmp3, val2_2, data_any]);
    return tmp3;
};


const rendering1 = (VAL) => VAL.map(V=> <option>{V}</option> );
// rendering2はコールバック関数を利用してonChange時に実行される
const rendering2 = (X) => (()=>console.log("change!! the "+ X +"ABC"));
const rendering3 = () => execute().map(VAL => (typeof VAL) === 'string' ? <li>{VAL}</li> : <select data-result={VAL[2]} onChange={rendering2(VAL[0])}>{rendering1(VAL[1])}</select> );

// useEffectの第二引数に空配列を渡すことで、初回レンダリング時のみ実行される
React.useEffect(() => {
    // console.log("初回レンダリング時のみ実行される");
}, []);
// useEffectの第二引数に値を渡すことで、値が変更された時のみ実行される
React.useEffect(() => {
    // console.log("値が変更された時のみ実行される");
}, [val2_1, val3_1]);
// useEffectの第二引数に何も渡さないことで、レンダリング時に毎回実行される
React.useEffect(() => {
    // console.log("レンダリング時に毎回実行される");
});

return (
<>

<div>
<textarea name="" id="" cols="10" rows="10" onChange={two_way_bind_val2_1}>{val2_1}</textarea>
<textarea name="" id="" cols="10" rows="10" onChange={two_way_bind_val3_1}>{val3_1}</textarea>
</div>

<div>
{ rendering3() }
</div>

</>
);
};
ReactDOM.createRoot(document.querySelector(".react_app")).render(
    <Neko1 />
);
</script>

<script>
// 配列の要素に正規表現に利用する記号が含まれている場合returnする関数
const checkRegExp = (ary) => {
    const reg = /[\^$\\.*+?()[\]{}|]/g;
    return ary.filter(V=> !reg.test(V));
};
</script>

<script>
// array that removed any element from array
const remove_any_elelemnt_from_ary_one_liner = (ary, val) => ary.filter(V=> V !== "");

// const f_i_b_composer = (FROM_ARY) => {
//     return data3.reduce((ACC, CURRENT_VAL) => {
//         const DATA_X = R.insert(0, '', shuffle(shuffle(remove_any_elelemnt_from_ary_one_liner(data3, CURRENT_VAL)).slice(0, 2).concat(CURRENT_VAL)));
//         const DATA_Y = [CURRENT_VAL, DATA_X, data3[1]];
//         ACC.push(DATA_Y);
//         return ACC;
//         },
//         []
//     );
// };




// .reduce((acc, cur) => acc.push(cur), [])

// ['foo',['', 'foo', 'blabla', 'brabra'], false,],

</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>portal</title>

<link rel="stylesheet" href="./lib/reset.css">
<style>
.f_c_app, .f_i_b_app, .i_t_n_app{
    display: grid;
    grid-template-columns: 10rem 2rem 1fr 1fr;
}
.parent_of_alert_and_textarea{
    display: grid;
    grid-template-areas: 
    "alert alert"
    "q_a_data_1 q_a_data_2";
    grid-template-rows:
    1rem
    1fr;
}
.alert{
    height: 1rem;
    grid-area: alert;
    color: blueviolet;
}
.q_a_data_1{
    grid-area: q_a_data_1;
}
.q_a_data_2{
    grid-area: q_a_data_2;
}
button, span{
    /* white-space: nowrap; */
    /* „ÉÜ„Ç≠„Çπ„Éà„ÅåÊîπË°å„Åï„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã */
    overflow: hidden; /* Ë¶™Ë¶ÅÁ¥†„Åã„Çâ„ÅØ„ÅøÂá∫„ÅüÈÉ®ÂàÜ„ÇíÈö†„Åô */
    text-overflow: ellipsis; /* ...„ÇíË°®Á§∫„Åó„Å¶„ÄÅÈï∑„ÅÑ„ÉÜ„Ç≠„Çπ„Éà„ÇíÈùûË°®Á§∫„Å´„Åô„Çã */
}
.TEXT{
    width: 2rem; /* Ë¶ÅÁ¥†„ÅÆÂπÖ„ÇíÊåáÂÆö„Åô„Çã */    
}

</style>
<script src="./lib/localforage@1.10.0.js"></script>
<script src="./lib/vue@3.2.36.global.prod.js"></script>
<script src="./lib/ramda.@0.28.0.js"></script>
</head>


<body>
<div class="name_password">
    name: <input type="text" v-model="name" class="name">
    password: <input type="text" v-model="password" class="password">
    <button @click="toggle_and_change">toggle_and_change</button>
</div>
<script>
    const name_password_app = Vue.createApp({
        data() {
            return {
                name: 'name1',
                password: 'password1',
            }
        },
        watch: {
            name: function (newVal, oldVal) {
                this.change_other_apps_name_password();
                // console.log('name changed');
            },
            password: function (newVal, oldVal) {
                this.change_other_apps_name_password();
                // console.log('password changed');
            },
        },
        beforeMounte(){
        },
        mounted() {
        },
        beforeUpdate() {
        },
        updated() {
        },
        methods: {
            // 'PUBLIC', 'delete_24_hours'
            // 'name1', 'password1'
            toggle(){
                this.name === 'name1' ? this.name = 'PUBLIC' : this.name = 'name1';
                this.password === 'password1' ? this.password = 'delete_24_hours' : this.password = 'password1';
            },
            change_other_apps_name_password(){
                [f_c_app.name, f_i_b_app.name, i_t_n_app.name]
                    = [this.name, this.name, this.name];
                [f_c_app.password, f_i_b_app.password, i_t_n_app.password]
                    = [this.password, this.password, this.password];
            },
            toggle_and_change(){
                this.toggle();
                this.change_other_apps_name_password();
            }
        },
    }).mount('.name_password');
</script>

<script>
// DROP TABLE IF EXISTS users;
// DROP TABLE IF EXISTS user_permission;
// DROP TABLE IF EXISTS f_c;
// DROP TABLE IF EXISTS f_i_b;
// DROP TABLE IF EXISTS i_t_n;


// CREATE TABLE users (
//   id INTEGER PRIMARY KEY AUTOINCREMENT,
//   role_id INTEGER NOT NULL,
//   name TEXT NOT NULL,
//   password TEXT NOT NULL,
//   created_at DATETIME NOT NULL,
//   updated_at DATETIME NOT NULL
// );
// CREATE TABLE user_permission (
//   id INTEGER PRIMARY KEY,

//   permission TEXT NOT NULL,
//   readable INTEGER NOT NULL,
//   writable INTEGER NOT NULL,
//   deletable INTEGER NOT NULL, 

//   created_at DATETIME NOT NULL,
//   updated_at DATETIME NOT NULL
// );

// CREATE TABLE f_c (
//   id INTEGER PRIMARY KEY AUTOINCREMENT,
//   user_id INTEGER NOT NULL,
//   content_1 TEXT NOT NULL,
//   content_2 TEXT NOT NULL,
//   created_at DATETIME NOT NULL,
//   updated_at DATETIME NOT NULL,
//   FOREIGN KEY (user_id) REFERENCES users(id)
// );

// CREATE TABLE f_i_b (
//   id INTEGER PRIMARY KEY AUTOINCREMENT,
//   user_id INTEGER NOT NULL,
//   content_1 TEXT NOT NULL,
//   content_2 TEXT NOT NULL,
//   created_at DATETIME NOT NULL,
//   updated_at DATETIME NOT NULL,
//   FOREIGN KEY (user_id) REFERENCES users(id)
// );
// CREATE TABLE i_t_n (
//   id INTEGER PRIMARY KEY AUTOINCREMENT,
//   user_id INTEGER NOT NULL,
//   content_1 TEXT NOT NULL,
//   content_2 TEXT NOT NULL,
//   created_at DATETIME NOT NULL,
//   updated_at DATETIME NOT NULL,
//   FOREIGN KEY (user_id) REFERENCES users(id)
// );

// INSERT INTO users (role_id, name, password, created_at, updated_at) VALUES (1, 'PUBLIC', 'delete_24_hours', DATETIME('now'), DATETIME('now'));
// INSERT INTO users (role_id, name, password, created_at, updated_at) VALUES (2, 'name1', 'password1', DATETIME('now'), DATETIME('now'));
// INSERT INTO user_permission (id, permission, readable, writable, deletable, created_at, updated_at) VALUES (1, 'guest', 1, 0, 0, DATETIME('now'), DATETIME('now'));
// INSERT INTO user_permission (id, permission, readable, writable, deletable, created_at, updated_at) VALUES (2, 'user', 1, 1, 1, DATETIME('now'), DATETIME('now'));
</script>



<div class="f_c_app">
    <div class="parent_of_alert_and_textarea">
        <p class="alert">{{ alert_val }}</p>
        <textarea name="" id="" cols="10" rows="10" v-model="f_c_data_1" class="f_c_data_1"></textarea>
        <textarea name="" id="" cols="10" rows="10" v-model="f_c_data_2" class="f_c_data_2"></textarea>
    </div>
    <button @click="f_c_save_data_to_f_c_all_save">f_c_save_data_to_f_c_all_save</button>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in f_c_all_save" class="save_data_set_list">
        <!-- <span @click="">{{ [DATAVAL[0].slice(0, 3), DATAVAL[1].slice(0, 3)]  }}</span> -->
        <span @click="">{{ DATAVAL[0].slice(0, 10)  }}</span>
        <button @click="f_c_save_data_delete(DATAIDX)" class="f_c_save_data_delete">üóëÔ∏è</button>
        <button @click="fetch_insert_f_c_by_POST(DATAVAL[0], DATAVAL[1])" class="fetch_insert_f_c_by_POST">üì§</button>
    
        <button @click="f_c_set_data_to_textarea(DATAVAL[0], DATAVAL[1])" class="f_c_set_data_to_textarea">ü•ç</button>
    </li>
    </ul>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in f_c_data_of_servers_fetched" class="save_data_set_list">
    <span @click="">{{ DATAVAL.content_1.slice(0, 30) }}</span>
    <span @click="">{{ DATAVAL.content_2.slice(0, 30) }}</span>
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_1).slice(0, 30) }}</span> -->
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_2).slice(0, 30) }}</span> -->
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_2).slice(0, 30) }}</span> -->
    <button @click="fetch_delete_f_c_by_POST(DATAVAL.id)">DELETE it</button>
    <button @click="f_c_save_data_to_localforage(DATAVAL.content_1, DATAVAL.content_2)">SAVE it to Your data</button>
    </li>
    </ul>
</div>

<script>
const f_c_app = Vue.createApp({
data() {
    return {
f_c_data_1: '',
f_c_data_2: '',

f_c_all_save: [],

name: 'name1',
password: 'password1',

HOST: 'http://localhost',
PORT: '8000',

f_c_data_of_servers_fetched: null,
alert_val: '',
}},
watch: {
f_c_data_1: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
f_c_data_2: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
},
beforeMounte(){
},
mounted() {
    this.f_c_save_data_load();
    this.fetch_read_f_c_by_GET();
},
beforeUpdate() {
},
updated() {
},
methods: {
to_ary(it){
    return JSON.parse(JSON.stringify(it));
},
alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string(){
    const true_if_within_4000_characters_and_not_empty = (str) => str.length > 2 && str.length <= 4000 && typeof str === 'string';
    this.alert_val = true_if_within_4000_characters_and_not_empty(JSON.stringify(this.f_c_data_1 + this.f_c_data_2)) ? '1-4000 OK' : '1-4000 NG';
    return true_if_within_4000_characters_and_not_empty(JSON.stringify(this.f_c_data_1 + this.f_c_data_2)) ? true : false;
},

async f_c_save_data_to_f_c_all_save(){
    if(this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string() === false){
        return;
    }
    this.f_c_all_save.push(this.to_ary([this.f_c_data_1, this.f_c_data_2]));
    await localforage.setItem('f_c', JSON.stringify(this.f_c_all_save));
},
async f_c_save_data_load() {
    this.f_c_all_save = JSON.parse(await localforage.getItem('f_c')) || [];
},
async f_c_save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??ü¶ñ\nÊú¨ÂΩì„Å´ÂâäÈô§„Åô„ÇãÔºü?ü¶ï\n" + R.zip(this.f_c_all_save[INDEX][0].split("\n"), this.f_c_all_save[INDEX][1].split("\n")).join("\n") )) {
        this.f_c_all_save.splice(INDEX, 1);
        await localforage.setItem('f_c', JSON.stringify(this.f_c_all_save));
    };
},
async f_c_set_data_to_textarea(f_c_data_1, f_c_data_2){
    this.f_c_data_1 = f_c_data_1;
    this.f_c_data_2 = f_c_data_2;
},
// f_c„ÅÆÂºïÊï∞„Çícontent_1, content_2„Çílocalforage„Å´ËøΩÂä†‰øùÂ≠ò„Åô„ÇãÈñ¢Êï∞
async f_c_save_data_to_localforage(content_1, content_2){
    const parsed_content_1 = content_1;
    const parsed_content_2 = content_2;
    this.f_c_all_save.push([parsed_content_1, parsed_content_2]);
    await localforage.setItem('f_c', JSON.stringify(this.f_c_all_save));
},

async fetch_read_f_c_by_GET(){
    const res = await fetch(this.HOST + ':' + this.PORT + '/read_f_c');
    const data = await res.json();
    this.f_c_data_of_servers_fetched = data;
},

async fetch_insert_f_c_by_POST(CONTENT_1, CONTENT_2){
    const res = await fetch(this.HOST + ':' + this.PORT + '/insert_f_c', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            content_1: CONTENT_1,
            content_2: CONTENT_2,
        }),
    });
    const data = await res.json();
    if(data.error){
        alert(data.error);
        return;
    }
    this.f_c_data_of_servers_fetched = data;
    console.log(data);
},

async fetch_delete_f_c_by_POST(ID){
    const res = await fetch(this.HOST + ':' + this.PORT + '/delete_f_c', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            id: ID,
        }),
    });
    const data = await res.json();
    this.f_c_data_of_servers_fetched = data;
    console.log(data);
},

},
}).mount('.f_c_app');
</script>





<div class="f_i_b_app">
    <div class="parent_of_alert_and_textarea">
        <p class="alert">{{ alert_val }}</p>
        <textarea name="" id="" cols="10" rows="10" v-model="f_i_b_data_1" class="f_i_b_data_1"></textarea>
        <textarea name="" id="" cols="10" rows="10" v-model="f_i_b_data_2" class="f_i_b_data_2"></textarea>
    </div>
    <button @click="f_i_b_save_data_to_f_i_b_all_save">f_i_b_save_data_to_f_i_b_all_save</button>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in f_i_b_all_save" class="save_data_set_list">
        <!-- <span @click="">{{ [DATAVAL[0].slice(0, 3), DATAVAL[1].slice(0, 3)]  }}</span> -->
        <span @click="">{{ DATAVAL[0].slice(0, 10)  }}</span>
        <button @click="f_i_b_save_data_delete(DATAIDX)" class="f_i_b_save_data_delete">üóëÔ∏è</button>
        <button @click="fetch_insert_f_i_b_by_POST(DATAVAL[0], DATAVAL[1])" class="fetch_insert_f_i_b_by_POST">üì§</button>
    
        <button @click="f_i_b_set_data_to_textarea(DATAVAL[0], DATAVAL[1])" class="f_i_b_set_data_to_textarea">ü•ç</button>
    </li>
    </ul>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in f_i_b_data_of_servers_fetched" class="save_data_set_list">
    <span @click="">{{ DATAVAL.content_1.slice(0, 30) }}</span>
    <span @click="">{{ DATAVAL.content_2.slice(0, 30) }}</span>
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_1).slice(0, 30) }}</span> -->
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_2).slice(0, 30) }}</span> -->
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_2).slice(0, 30) }}</span> -->
    <button @click="fetch_delete_f_i_b_by_POST(DATAVAL.id)">DELETE it</button>
    <button @click="f_i_b_save_data_to_localforage(DATAVAL.content_1, DATAVAL.content_2)">SAVE it to Your data</button>
    </li>
    </ul>
</div>

<script>
const f_i_b_app = Vue.createApp({
data() {
    return {
f_i_b_data_1: '',
f_i_b_data_2: '',

f_i_b_all_save: [],

name: 'name1',
password: 'password1',

HOST: 'http://localhost',
PORT: '8000',

f_i_b_data_of_servers_fetched: null,
alert_val: '',
}},
watch: {
f_i_b_data_1: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
f_i_b_data_2: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
},
beforeMounte(){
},
mounted() {
    this.f_i_b_save_data_load();
    this.fetch_read_f_i_b_by_GET();
},
beforeUpdate() {
},
updated() {
},
methods: {
to_ary(it){
    return JSON.parse(JSON.stringify(it));
},
alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string(){
    const true_if_within_4000_characters_and_not_empty = (str) => str.length > 2 && str.length <= 4000 && typeof str === 'string';
    this.alert_val = true_if_within_4000_characters_and_not_empty(JSON.stringify(this.f_i_b_data_1 + this.f_i_b_data_2)) ? '1-4000 OK' : '1-4000 NG';
    return true_if_within_4000_characters_and_not_empty(JSON.stringify(this.f_i_b_data_1 + this.f_i_b_data_2)) ? true : false;
},

async f_i_b_save_data_to_f_i_b_all_save(){
    if(this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string() === false){
        return;
    }
    this.f_i_b_all_save.push(this.to_ary([this.f_i_b_data_1, this.f_i_b_data_2]));
    await localforage.setItem('f_i_b', JSON.stringify(this.f_i_b_all_save));
},
async f_i_b_save_data_load() {
    this.f_i_b_all_save = JSON.parse(await localforage.getItem('f_i_b')) || [];
},
async f_i_b_save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??ü¶ñ\nÊú¨ÂΩì„Å´ÂâäÈô§„Åô„ÇãÔºü?ü¶ï\n" + R.zip(this.f_i_b_all_save[INDEX][0].split("\n"), this.f_i_b_all_save[INDEX][1].split("\n")).join("\n") )) {
        this.f_i_b_all_save.splice(INDEX, 1);
        await localforage.setItem('f_i_b', JSON.stringify(this.f_i_b_all_save));
    };
},
async f_i_b_set_data_to_textarea(f_i_b_data_1, f_i_b_data_2){
    this.f_i_b_data_1 = f_i_b_data_1;
    this.f_i_b_data_2 = f_i_b_data_2;
},
// f_i_b„ÅÆÂºïÊï∞„Çícontent_1, content_2„Çílocalforage„Å´ËøΩÂä†‰øùÂ≠ò„Åô„ÇãÈñ¢Êï∞
async f_i_b_save_data_to_localforage(content_1, content_2){
    const parsed_content_1 = content_1;
    const parsed_content_2 = content_2;
    this.f_i_b_all_save.push([parsed_content_1, parsed_content_2]);
    await localforage.setItem('f_i_b', JSON.stringify(this.f_i_b_all_save));
},

async fetch_read_f_i_b_by_GET(){
    const res = await fetch(this.HOST + ':' + this.PORT + '/read_f_i_b');
    const data = await res.json();
    this.f_i_b_data_of_servers_fetched = data;
},

async fetch_insert_f_i_b_by_POST(CONTENT_1, CONTENT_2){
    const res = await fetch(this.HOST + ':' + this.PORT + '/insert_f_i_b', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            content_1: CONTENT_1,
            content_2: CONTENT_2,
        }),
    });
    const data = await res.json();
    if(data.error){
        alert(data.error);
        return;
    }
    this.f_i_b_data_of_servers_fetched = data;
    console.log(data);
},

async fetch_delete_f_i_b_by_POST(ID){
    const res = await fetch(this.HOST + ':' + this.PORT + '/delete_f_i_b', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            id: ID,
        }),
    });
    const data = await res.json();
    this.f_i_b_data_of_servers_fetched = data;
    console.log(data);
},

},
}).mount('.f_i_b_app');
</script>






<div class="i_t_n_app">
    <div class="parent_of_alert_and_textarea">
        <p class="alert">{{ alert_val }}</p>
        <textarea name="" id="" cols="10" rows="10" v-model="i_t_n_data_1" class="i_t_n_data_1"></textarea>
        <textarea name="" id="" cols="10" rows="10" v-model="i_t_n_data_2" class="i_t_n_data_2"></textarea>
    </div>
    <button @click="i_t_n_save_data_to_i_t_n_all_save">i_t_n_save_data_to_i_t_n_all_save</button>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in i_t_n_all_save" class="save_data_set_list">
        <!-- <span @click="">{{ [DATAVAL[0].slice(0, 3), DATAVAL[1].slice(0, 3)]  }}</span> -->
        <span @click="">{{ DATAVAL[0].slice(0, 10)  }}</span>
        <button @click="i_t_n_save_data_delete(DATAIDX)" class="i_t_n_save_data_delete">üóëÔ∏è</button>
        <button @click="fetch_insert_i_t_n_by_POST(DATAVAL[0], DATAVAL[1])" class="fetch_insert_i_t_n_by_POST">üì§</button>
    
        <button @click="i_t_n_set_data_to_textarea(DATAVAL[0], DATAVAL[1])" class="i_t_n_set_data_to_textarea">ü•ç</button>
    </li>
    </ul>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in i_t_n_data_of_servers_fetched" class="save_data_set_list">
    <span @click="">{{ DATAVAL.content_1.slice(0, 30) }}</span>
    <span @click="">{{ DATAVAL.content_2.slice(0, 30) }}</span>
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_1).slice(0, 30) }}</span> -->
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_2).slice(0, 30) }}</span> -->
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content_2).slice(0, 30) }}</span> -->
    <button @click="fetch_delete_i_t_n_by_POST(DATAVAL.id)">DELETE it</button>
    <button @click="i_t_n_save_data_to_localforage(DATAVAL.content_1, DATAVAL.content_2)">SAVE it to Your data</button>
    </li>
    </ul>
</div>

<script>
const i_t_n_app = Vue.createApp({
data() {
    return {
i_t_n_data_1: '',
i_t_n_data_2: '',

i_t_n_all_save: [],

name: 'name1',
password: 'password1',

HOST: 'http://localhost',
PORT: '8000',

i_t_n_data_of_servers_fetched: null,
alert_val: '',
}},
watch: {
i_t_n_data_1: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
i_t_n_data_2: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
},
beforeMounte(){
},
mounted() {
    this.i_t_n_save_data_load();
    this.fetch_read_i_t_n_by_GET();
},
beforeUpdate() {
},
updated() {
},
methods: {
to_ary(it){
    return JSON.parse(JSON.stringify(it));
},
alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string(){
    const true_if_within_4000_characters_and_not_empty = (str) => str.length > 2 && str.length <= 4000 && typeof str === 'string';
    this.alert_val = true_if_within_4000_characters_and_not_empty(JSON.stringify(this.i_t_n_data_1 + this.i_t_n_data_2)) ? '1-4000 OK' : '1-4000 NG';
    return true_if_within_4000_characters_and_not_empty(JSON.stringify(this.i_t_n_data_1 + this.i_t_n_data_2)) ? true : false;
},

async i_t_n_save_data_to_i_t_n_all_save(){
    if(this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string() === false){
        return;
    }
    this.i_t_n_all_save.push(this.to_ary([this.i_t_n_data_1, this.i_t_n_data_2]));
    await localforage.setItem('i_t_n', JSON.stringify(this.i_t_n_all_save));
},
async i_t_n_save_data_load() {
    this.i_t_n_all_save = JSON.parse(await localforage.getItem('i_t_n')) || [];
},
async i_t_n_save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??ü¶ñ\nÊú¨ÂΩì„Å´ÂâäÈô§„Åô„ÇãÔºü?ü¶ï\n" + R.zip(this.i_t_n_all_save[INDEX][0].split("\n"), this.i_t_n_all_save[INDEX][1].split("\n")).join("\n") )) {
        this.i_t_n_all_save.splice(INDEX, 1);
        await localforage.setItem('i_t_n', JSON.stringify(this.i_t_n_all_save));
    };
},
async i_t_n_set_data_to_textarea(i_t_n_data_1, i_t_n_data_2){
    this.i_t_n_data_1 = i_t_n_data_1;
    this.i_t_n_data_2 = i_t_n_data_2;
},
// i_t_n„ÅÆÂºïÊï∞„Çícontent_1, content_2„Çílocalforage„Å´ËøΩÂä†‰øùÂ≠ò„Åô„ÇãÈñ¢Êï∞
async i_t_n_save_data_to_localforage(content_1, content_2){
    const parsed_content_1 = content_1;
    const parsed_content_2 = content_2;
    this.i_t_n_all_save.push([parsed_content_1, parsed_content_2]);
    await localforage.setItem('i_t_n', JSON.stringify(this.i_t_n_all_save));
},

async fetch_read_i_t_n_by_GET(){
    const res = await fetch(this.HOST + ':' + this.PORT + '/read_i_t_n');
    const data = await res.json();
    this.i_t_n_data_of_servers_fetched = data;
},

async fetch_insert_i_t_n_by_POST(CONTENT_1, CONTENT_2){
    const res = await fetch(this.HOST + ':' + this.PORT + '/insert_i_t_n', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            content_1: CONTENT_1,
            content_2: CONTENT_2,
        }),
    });
    const data = await res.json();
    if(data.error){
        alert(data.error);
        return;
    }
    this.i_t_n_data_of_servers_fetched = data;
    console.log(data);
},

async fetch_delete_i_t_n_by_POST(ID){
    const res = await fetch(this.HOST + ':' + this.PORT + '/delete_i_t_n', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            id: ID,
        }),
    });
    const data = await res.json();
    this.i_t_n_data_of_servers_fetched = data;
    console.log(data);
},

},
}).mount('.i_t_n_app');
</script>



<script>
// f_c_app, f_i_b_app, i_t_n_app„Åù„Çå„Åû„Çå„ÅÆthis.name„Å®this.password„Çí name: 'name1',„ÄÄpassword: 'password1' „ÇÇ„Åó„Åè„ÅØ name: 'PUBLIC', password: 'delete_24_hours' „Å´Â§âÊõ¥„Åô„ÇãÈñ¢Êï∞
// 'PUBLIC', 'delete_24_hours'
// 'name1', 'password1'

// Ê≠£Â∏∏Á≥ª
// fetch('http://localhost:8000/insert_f_c', {
//     method: 'POST',
//     headers: {
//         'Content-Type': 'application/json',
//     },
//     body: JSON.stringify({
//         name: 'name1',
//         password: 'password1',
//         content_1: 'content_1'.repeat(10),
//         content_2: 'content_2'.repeat(10),
//     }),
// }).then(res => res.json()).then(data => console.log(data));
// Áï∞Â∏∏Á≥ª
// fetch('http://localhost:8000/insert_f_c', {
//     method: 'POST',
//     headers: {
//         'Content-Type': 'application/json',
//     },
//     body: JSON.stringify({
//         name: 'name1',
//         password: 'password1',
//         content_1: 'content_1'.repeat(1000),
//         content_2: 'content_2'.repeat(1000),
//     }),
// }).then(res => res.json()).then(data => console.log(data));


</script>
</body>
</html>
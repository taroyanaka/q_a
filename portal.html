<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>portal</title>

<link rel="stylesheet" href="./lib/reset.css">
<style>
.F_C_app, .F_I_B_app, .I_T_N_app{
    display: grid;
    grid-template-columns: 10rem 2rem 1fr 1fr;
}
.parent_of_alert_and_textarea{
    display: grid;
    grid-template-areas: 
    "alert alert"
    "q_a_data_1 q_a_data_2";
    grid-template-rows:
    1rem
    1fr;
}
.alert{
    height: 1rem;
    grid-area: alert;
    color: blueviolet;
}
.q_a_data_1{
    grid-area: q_a_data_1;
}
.q_a_data_2{
    grid-area: q_a_data_2;
}
button, span{
    /* white-space: nowrap; */
    /* ãƒ†ã‚­ã‚¹ãƒˆãŒæ”¹è¡Œã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹ */
    overflow: hidden; /* è¦ªè¦ç´ ã‹ã‚‰ã¯ã¿å‡ºãŸéƒ¨åˆ†ã‚’éš ã™ */
    text-overflow: ellipsis; /* ...ã‚’è¡¨ç¤ºã—ã¦ã€é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’éè¡¨ç¤ºã«ã™ã‚‹ */
}
.TEXT{
    width: 2rem; /* è¦ç´ ã®å¹…ã‚’æŒ‡å®šã™ã‚‹ */    
}

</style>
<script src="./lib/localforage@1.10.0.js"></script>
<script src="./lib/vue@3.2.36.global.prod.js"></script>
<script src="./lib/ramda.@0.28.0.js"></script>
</head>


<body>
<div class="name_password">
    name: <input type="text" v-model="name" class="name">
    password: <input type="text" v-model="password" class="password">
    <button @click="toggle_and_change">toggle_and_change</button>
</div>
<script>
    const name_password_app = Vue.createApp({
        data() {
            return {
                name: 'name1',
                password: 'password1',
            }
        },
        watch: {
            name: function (newVal, oldVal) {
                this.change_other_apps_name_password();
                // console.log('name changed');
            },
            password: function (newVal, oldVal) {
                this.change_other_apps_name_password();
                // console.log('password changed');
            },
        },
        beforeMounte(){
        },
        mounted() {
        },
        beforeUpdate() {
        },
        updated() {
        },
        methods: {
            // 'PUBLIC', 'delete_24_hours'
            // 'name1', 'password1'
            toggle(){
                this.name === 'name1' ? this.name = 'PUBLIC' : this.name = 'name1';
                this.password === 'password1' ? this.password = 'delete_24_hours' : this.password = 'password1';
            },
            change_other_apps_name_password(){
                [F_C_app.name, F_I_B_app.name, I_T_N_app.name]
                    = [this.name, this.name, this.name];
                [F_C_app.password, F_I_B_app.password, I_T_N_app.password]
                    = [this.password, this.password, this.password];
            },
            toggle_and_change(){
                this.toggle();
                this.change_other_apps_name_password();
            }
        },
    }).mount('.name_password');
</script>


<div class="F_C_app">
    <div class="parent_of_alert_and_textarea">
        <p class="alert">{{ alert_val }}</p>
        <textarea name="" id="" cols="10" rows="10" v-model="q_a_data_1" class="q_a_data_1"></textarea>
        <textarea name="" id="" cols="10" rows="10" v-model="q_a_data_2" class="q_a_data_2"></textarea>
    </div>
    <button @click="q_a_save_data_to_q_a_all_save">q_a_save_data_to_q_a_all_save</button>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in q_a_all_save" class="save_data_set_list">
        <!-- <span @click="">{{ [DATAVAL[0].slice(0, 3), DATAVAL[1].slice(0, 3)]  }}</span> -->
        <span @click="">{{ DATAVAL[0].slice(0, 10)  }}</span>
        <button @click="q_a_save_data_delete(DATAIDX)" class="q_a_save_data_delete">ğŸ—‘ï¸</button>
        <button @click="fetch_insert_q_a_by_POST(DATAVAL)" class="fetch_insert_q_a_by_POST">ğŸ“¤</button>
    
        <button @click="q_a_set_data_to_textarea(DATAVAL[0], DATAVAL[1])" class="q_a_set_data_to_textarea">ğŸ¥</button>
    </li>
    </ul>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in q_a_data_of_servers_fetched" class="save_data_set_list">
    <span @click="">{{ JSON.parse(DATAVAL.content)[0].slice(0, 30) }}</span>
    <span @click="">{{ JSON.parse(DATAVAL.content)[1].slice(0, 100) }}</span>
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content)[1].slice(0, 10) }}</span> -->
    <!-- <span @click="">{{ DATAVAL.created_at }}</span> -->
    <!-- <span @click="">{{ DATAVAL.name }}</span> -->
    <!-- <span @click="">{{ DATAVAL.updated_at }}</span> -->
    <button @click="fetch_delete_q_a_by_POST(DATAVAL.id)">DELETE it</button>
    <button @click="q_a_save_data_to_localforage(DATAVAL.content)">SAVE it to Your data</button>
    </li>
    </ul>
</div>

<script>
const F_C_app = Vue.createApp({
data() {
    return {
q_a_data_1: '',
q_a_data_2: '',

q_a_all_save: [],

name: 'name1',
password: 'password1',

HOST: 'http://localhost',
PORT: '8000',

q_a_data_of_servers_fetched: null,
alert_val: '',
}},
watch: {
q_a_data_1: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
q_a_data_2: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
},
beforeMounte(){
},
mounted() {
    this.q_a_save_data_load();
    this.fetch_read_q_a_by_GET();
},
beforeUpdate() {
},
updated() {
},
methods: {
to_ary(it){
    return JSON.parse(JSON.stringify(it));
},
alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string(){
    const true_if_within_4000_characters_and_not_empty = (str) => str.length > 2 && str.length <= 4000 && typeof str === 'string';
    this.alert_val = true_if_within_4000_characters_and_not_empty(JSON.stringify(this.q_a_data_1 + this.q_a_data_2)) ? '1-4000 OK' : '1-4000 NG';
    return true_if_within_4000_characters_and_not_empty(JSON.stringify(this.q_a_data_1 + this.q_a_data_2)) ? true : false;
},

async q_a_save_data_to_q_a_all_save(){
    if(this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string() === false){
        return;
    }
    this.q_a_all_save.push(this.to_ary([this.q_a_data_1, this.q_a_data_2]));
    await localforage.setItem('q_a_1', JSON.stringify(this.q_a_all_save));
},
async q_a_save_data_load() {
    this.q_a_all_save = JSON.parse(await localforage.getItem('q_a_1')) || [];
},
async q_a_save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??ğŸ¦–\næœ¬å½“ã«å‰Šé™¤ã™ã‚‹ï¼Ÿ?ğŸ¦•\n" + R.zip(this.q_a_all_save[INDEX][0].split("\n"), this.q_a_all_save[INDEX][1].split("\n")).join("\n") )) {
        this.q_a_all_save.splice(INDEX, 1);
        await localforage.setItem('q_a_1', JSON.stringify(this.q_a_all_save));
    };
},
async q_a_set_data_to_textarea(q_a_data_1, q_a_data_2){
    this.q_a_data_1 = q_a_data_1;
    this.q_a_data_2 = q_a_data_2;
},
// q_aã®å¼•æ•°ã‚’contentã‚’localforageã«è¿½åŠ ä¿å­˜ã™ã‚‹é–¢æ•°
async q_a_save_data_to_localforage(content){
    const parsed_content = JSON.parse(content);
    this.q_a_all_save.push(parsed_content);
    await localforage.setItem('q_a_1', JSON.stringify(this.q_a_all_save));
},

async fetch_read_q_a_by_GET(){
    const res = await fetch(this.HOST + ':' + this.PORT + '/read_q_a');
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
},

async fetch_insert_q_a_by_POST(CONTENT){
    const res = await fetch(this.HOST + ':' + this.PORT + '/insert_q_a', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            content: CONTENT,
        }),
    });
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
    console.log(data);
},

async fetch_delete_q_a_by_POST(ID){
    const res = await fetch(this.HOST + ':' + this.PORT + '/delete_q_a', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            id: ID,
        }),
    });
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
    console.log(data);
},

},
}).mount('.F_C_app');
</script>

















<div class="F_I_B_app">
    <div class="parent_of_alert_and_textarea">
        <p class="alert">{{ alert_val }}</p>
        <textarea name="" id="" cols="10" rows="10" v-model="q_a_data_1" class="q_a_data_1"></textarea>
        <textarea name="" id="" cols="10" rows="10" v-model="q_a_data_2" class="q_a_data_2"></textarea>
    </div>
    <button @click="q_a_save_data_to_q_a_all_save">q_a_save_data_to_q_a_all_save</button>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in q_a_all_save" class="save_data_set_list">
        <!-- <span @click="">{{ [DATAVAL[0].slice(0, 3), DATAVAL[1].slice(0, 3)]  }}</span> -->
        <span @click="">{{ DATAVAL[0].slice(0, 10)  }}</span>
        <button @click="q_a_save_data_delete(DATAIDX)" class="q_a_save_data_delete">ğŸ—‘ï¸</button>
        <button @click="fetch_insert_q_a_by_POST(DATAVAL)" class="fetch_insert_q_a_by_POST">ğŸ“¤</button>
    
        <button @click="q_a_set_data_to_textarea(DATAVAL[0], DATAVAL[1])" class="q_a_set_data_to_textarea">ğŸ¥</button>
    </li>
    </ul>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in q_a_data_of_servers_fetched" class="save_data_set_list">
    <span @click="">{{ JSON.parse(DATAVAL.content)[0].slice(0, 30) }}</span>
    <span @click="">{{ JSON.parse(DATAVAL.content)[1].slice(0, 100) }}</span>
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content)[1].slice(0, 10) }}</span> -->
    <!-- <span @click="">{{ DATAVAL.created_at }}</span> -->
    <!-- <span @click="">{{ DATAVAL.name }}</span> -->
    <!-- <span @click="">{{ DATAVAL.updated_at }}</span> -->
    <button @click="fetch_delete_q_a_by_POST(DATAVAL.id)">DELETE it</button>
    <button @click="q_a_save_data_to_localforage(DATAVAL.content)">SAVE it to Your data</button>
    </li>
    </ul>
</div>

<script>
const F_I_B_app = Vue.createApp({
data() {
    return {
q_a_data_1: '',
q_a_data_2: '',

q_a_all_save: [],

name: 'name1',
password: 'password1',

HOST: 'http://localhost',
PORT: '8000',

q_a_data_of_servers_fetched: null,
alert_val: '',
}},
watch: {
q_a_data_1: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
q_a_data_2: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
},
beforeMounte(){
},
mounted() {
    this.q_a_save_data_load();
    this.fetch_read_q_a_by_GET();
},
beforeUpdate() {
},
updated() {
},
methods: {
to_ary(it){
    return JSON.parse(JSON.stringify(it));
},
alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string(){
    const true_if_within_4000_characters_and_not_empty = (str) => str.length > 2 && str.length <= 4000 && typeof str === 'string';
    this.alert_val = true_if_within_4000_characters_and_not_empty(JSON.stringify(this.q_a_data_1 + this.q_a_data_2)) ? '1-4000 OK' : '1-4000 NG';
    return true_if_within_4000_characters_and_not_empty(JSON.stringify(this.q_a_data_1 + this.q_a_data_2)) ? true : false;
},

async q_a_save_data_to_q_a_all_save(){
    if(this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string() === false){
        return;
    }
    this.q_a_all_save.push(this.to_ary([this.q_a_data_1, this.q_a_data_2]));
    await localforage.setItem('q_a_1', JSON.stringify(this.q_a_all_save));
},
async q_a_save_data_load() {
    this.q_a_all_save = JSON.parse(await localforage.getItem('F_I_B')) || [];
},
async q_a_save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??ğŸ¦–\næœ¬å½“ã«å‰Šé™¤ã™ã‚‹ï¼Ÿ?ğŸ¦•\n" + R.zip(this.q_a_all_save[INDEX][0].split("\n"), this.q_a_all_save[INDEX][1].split("\n")).join("\n") )) {
        this.q_a_all_save.splice(INDEX, 1);
        await localforage.setItem('F_I_B', JSON.stringify(this.q_a_all_save));
    };
},
async q_a_set_data_to_textarea(q_a_data_1, q_a_data_2){
    this.q_a_data_1 = q_a_data_1;
    this.q_a_data_2 = q_a_data_2;
},
// q_aã®å¼•æ•°ã‚’contentã‚’localforageã«è¿½åŠ ä¿å­˜ã™ã‚‹é–¢æ•°
async q_a_save_data_to_localforage(content){
    const parsed_content = JSON.parse(content);
    this.q_a_all_save.push(parsed_content);
    await localforage.setItem('F_I_B', JSON.stringify(this.q_a_all_save));
},





async fetch_read_q_a_by_GET(){
    const res = await fetch(this.HOST + ':' + this.PORT + '/read_f_i_b');
    const data = await res.json();
    console.log(data);
    this.q_a_data_of_servers_fetched = data;
},

async fetch_insert_q_a_by_POST(CONTENT){
    const res = await fetch(this.HOST + ':' + this.PORT + '/insert_f_i_b', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            content: CONTENT,
        }),
    });
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
    console.log(data);
},

async fetch_delete_q_a_by_POST(ID){
    const res = await fetch(this.HOST + ':' + this.PORT + '/delete_f_i_b', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            id: ID,
        }),
    });
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
    console.log(data);
},

},
}).mount('.F_I_B_app');
</script>












<div class="I_T_N_app">
    <div class="parent_of_alert_and_textarea">
        <p class="alert">{{ alert_val }}</p>
        <textarea name="" id="" cols="10" rows="10" v-model="q_a_data_1" class="q_a_data_1"></textarea>
        <textarea name="" id="" cols="10" rows="10" v-model="q_a_data_2" class="q_a_data_2"></textarea>
    </div>
    <button @click="q_a_save_data_to_q_a_all_save">q_a_save_data_to_q_a_all_save</button>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in q_a_all_save" class="save_data_set_list">
        <!-- <span @click="">{{ [DATAVAL[0].slice(0, 3), DATAVAL[1].slice(0, 3)]  }}</span> -->
        <span @click="">{{ DATAVAL[0].slice(0, 10)  }}</span>
        <button @click="q_a_save_data_delete(DATAIDX)" class="q_a_save_data_delete">ğŸ—‘ï¸</button>
        <button @click="fetch_insert_q_a_by_POST(DATAVAL)" class="fetch_insert_q_a_by_POST">ğŸ“¤</button>
    
        <button @click="q_a_set_data_to_textarea(DATAVAL[0], DATAVAL[1])" class="q_a_set_data_to_textarea">ğŸ¥</button>
    </li>
    </ul>
    
    <ul class="save_data_set_list_parent" style='display: block;'>
    <li v-for="(DATAVAL, DATAIDX) in q_a_data_of_servers_fetched" class="save_data_set_list">
    <span @click="">{{ JSON.parse(DATAVAL.content)[0].slice(0, 3) }}</span>
    <span @click="">{{ JSON.parse(DATAVAL.content)[1].slice(0, 100) }}</span>
    <!-- <span @click="">{{ JSON.parse(DATAVAL.content)[1].slice(0, 10) }}</span> -->
    <!-- <span @click="">{{ DATAVAL.created_at }}</span> -->
    <!-- <span @click="">{{ DATAVAL.name }}</span> -->
    <!-- <span @click="">{{ DATAVAL.updated_at }}</span> -->
    <button @click="fetch_delete_q_a_by_POST(DATAVAL.id)">DELETE it</button>
    <button @click="q_a_save_data_to_localforage(DATAVAL.content)">SAVE it to Your data</button>
    </li>
    </ul>
</div>

<script>
const I_T_N_app = Vue.createApp({
data() {
    return {
q_a_data_1: '',
q_a_data_2: '',

q_a_all_save: [],

name: 'name1',
password: 'password1',

HOST: 'http://localhost',
PORT: '8000',

q_a_data_of_servers_fetched: null,
alert_val: '',
}},
watch: {
q_a_data_1: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
q_a_data_2: {
    handler() {
        this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string();
    },
    deep: true
},
},
beforeMounte(){
},
mounted() {
    this.q_a_save_data_load();
    this.fetch_read_q_a_by_GET();
},
beforeUpdate() {
},
updated() {
},
methods: {
to_ary(it){
    return JSON.parse(JSON.stringify(it));
},
alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string(){
    const true_if_within_4000_characters_and_not_empty = (str) => str.length > 2 && str.length <= 4000 && typeof str === 'string';
    this.alert_val = true_if_within_4000_characters_and_not_empty(JSON.stringify(this.q_a_data_1 + this.q_a_data_2)) ? '1-4000 OK' : '1-4000 NG';
    return true_if_within_4000_characters_and_not_empty(JSON.stringify(this.q_a_data_1 + this.q_a_data_2)) ? true : false;
},


async q_a_save_data_to_q_a_all_save(){
    if(this.alert_to_alert_val_if_within_4000_characters_data1_and_data2_json_string() === false){
        return;
    }
    this.q_a_all_save.push(this.to_ary([this.q_a_data_1, this.q_a_data_2]));
    await localforage.setItem('I_T_N', JSON.stringify(this.q_a_all_save));
},
async q_a_save_data_load() {
    this.q_a_all_save = JSON.parse(await localforage.getItem('I_T_N')) || [];
},
async q_a_save_data_delete(INDEX){
    if (window.confirm("Do you really want to delete??ğŸ¦–\næœ¬å½“ã«å‰Šé™¤ã™ã‚‹ï¼Ÿ?ğŸ¦•\n" + R.zip(this.q_a_all_save[INDEX][0].split("\n"), this.q_a_all_save[INDEX][1].split("\n")).join("\n") )) {
        this.q_a_all_save.splice(INDEX, 1);
        await localforage.setItem('I_T_N', JSON.stringify(this.q_a_all_save));
    };
},
async q_a_set_data_to_textarea(q_a_data_1, q_a_data_2){
    this.q_a_data_1 = q_a_data_1;
    this.q_a_data_2 = q_a_data_2;
},
// q_aã®å¼•æ•°ã‚’contentã‚’localforageã«è¿½åŠ ä¿å­˜ã™ã‚‹é–¢æ•°
async q_a_save_data_to_localforage(content){
    const parsed_content = JSON.parse(content);
    this.q_a_all_save.push(parsed_content);
    await localforage.setItem('I_T_N', JSON.stringify(this.q_a_all_save));
},





async fetch_read_q_a_by_GET(){
    const res = await fetch(this.HOST + ':' + this.PORT + '/read_i_t_n');
    const data = await res.json();
    console.log(data);
    this.q_a_data_of_servers_fetched = data;
},

async fetch_insert_q_a_by_POST(CONTENT){
    const res = await fetch(this.HOST + ':' + this.PORT + '/insert_i_t_n', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            content: CONTENT,
        }),
    });
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
    console.log(data);
},

async fetch_delete_q_a_by_POST(ID){
    const res = await fetch(this.HOST + ':' + this.PORT + '/delete_i_t_n', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: this.name,
            password: this.password,
            id: ID,
        }),
    });
    const data = await res.json();
    this.q_a_data_of_servers_fetched = data;
    console.log(data);
},

},
}).mount('.I_T_N_app');



</script>




<script>
// F_C_app, F_I_B_app, I_T_N_appãã‚Œãã‚Œã®this.nameã¨this.passwordã‚’ name: 'name1',ã€€password: 'password1' ã‚‚ã—ãã¯ name: 'PUBLIC', password: 'delete_24_hours' ã«å¤‰æ›´ã™ã‚‹é–¢æ•°
// 'PUBLIC', 'delete_24_hours'
// 'name1', 'password1'
</script>
</body>
</html>
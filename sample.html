<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>memory system of tile style: sample</title>

<!-- <link rel="manifest" href="manifest.json"> -->

<!-- https://taroyanaka.github.io/q_a/sample_data_for_index3.txt -->

<link rel="stylesheet" href="./lib/reset.css">
<!-- <script src="./lib/localforage@1.10.0.js"></script> -->
<script src="./lib/vue@3.2.36.global.prod.js"></script>
<script src="./lib/ramda.@0.28.0.js"></script>
<script src="./lib/shuffle.js"></script>
<script src="./lib/my_global_function_for_q_a.js" defer></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/vue@3.2.45/dist/vue.global.prod.js"></script> -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/ramda/0.28.0/ramda.min.js"></script> -->
<style>
:root {
}
.app{
}
.block1{
    font-size: 1rem;
}
input[type="text"]{
    width: 3rem;
    height: 1rem;
}
button{
    /* buttonのborderを消す */
    border: none;

    width: 1rem;
    height: 20px;
}
.change_to_no_show_all{
    /* 画面に追従して常に示する */
    position: fixed;
    bottom: 0;
    left: 0;
    background-color: rgba(0, 0, 0, 0.1);
    padding: 0.5rem;
    font-size: 1.2rem;
    z-index: 1;
}
.remove_all_checked_items{
    /* 画面に追従して常に示する */
    position: fixed;
    bottom: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.1);
    padding: 0.5rem;
    font-size: 1.2rem;
    z-index: 1;
}
/* 画面端で要素が折り返され内容に設定するCSSを.appに適用する */
.app *{
    /* 画面端で要素が折り返され内容に設定するCSS */
    white-space: pre-wrap;
    /* 画面端で要素が折り返され内容に設定するCSS */
    word-break: break-all;
    display: flex;
    flex-wrap: nowrap;
}

.center_bottom{
    position: fixed;
    bottom: 0;
    left: 0;
}
/* checkboxを2倍の大きさにする */
input[type="checkbox"] {
    transform: scale(2);
    margin-right: 1rem;
}

</style>
</head>
<body class="app">
<div id="parent_block" data-x="0" data-y="0" style="position: relative;" >
    <div class="block1"
    :data-x="VAL[0]"
    :data-y="VAL[1]"
    :style="'position: absolute;' + 'left: ' + (VAL[0]*x_rem) + 'rem;' + 'top: ' + (VAL[1]*y_rem) + 'rem;'"
    v-for="(VAL, IDX) in data1"
    >
        <input type="text" 
        :style="{ 'color': (VAL[4]['no_show'] === true ? 'transparent' : 'black') }"
        v-model="data1[IDX][2][ data1[IDX][2]['now'] ]">
        <button :style="{ 'display': ( checked_items['add_x'] === false ? 'none' : 'inline') }" @click="add_x(IDX)">x</button>
        <button :style="{ 'display': ( checked_items['add_y'] === false ? 'none' : 'inline') }" @click="add_y(IDX)">y</button>
        <button :style="{ 'display': ( checked_items['remove_block'] === false ? 'none' : 'inline') }" @click="remove_block(IDX)">/</button>
        <button :style="{ 'display': ( checked_items['flip'] === false ? 'none' : 'inline') }" @click="flip(IDX)">|</button>
        <button :style="{ 'display': ( checked_items['change_to_no_show'] === false ? 'none' : 'inline') }" @click="change_to_no_show(IDX)">!</button>
        <button :style="{ 'display': ( checked_items['change_show_full'] === false ? 'none' : 'inline') }" @click="change_show_full(IDX)">0</button>
        <button :style="{ 'display': ( checked_items['change_show_first'] === false ? 'none' : 'inline') }" @click="change_show_first(IDX)">1</button>
        <button :style="{ 'display': ( checked_items['change_show_last'] === false ? 'none' : 'inline') }" @click="change_show_last(IDX)">-</button>
    </div>
</div>

<div class="change_to_no_show_all">
    <button @click="change_to_no_show_all()">!</button>
</div>
<div class="remove_all_checked_items">
    <button @click="remove_all_checked_items">&</button>
</div>

<template class="center_bottom">
    <div>
      <div v-for="(item, index) in checked_items" :key="index">
        <input type="checkbox" :value="item" v-model="checked_items[index]" @change="checked_items_fn(index)">{{ index }}
      </div>
      <!-- <div>Checked items: {{ checked_items }}</div> -->
    </div>
</template>      


</body>
<script>
const app = Vue.createApp({
data() {
return {
display_none_or_inline: false,
original_x_rem: 12,
original_y_rem: 1.3,
x_rem: 12,
y_rem: 1.3,
short_x_rem: 3.5,
short_y_rem: 1.3,
data1_template: [
        {now: 'full', full: 'text10', first: 't', last: '0'},
        {now: 'full', full: 'TEXT22', first: 'T', last: '2'},
        {no_show: false},
    ],
data1: [],
test_mode: true,
// test_mode: false,
all_show_or_none: 'show',

checked_items: {
add_x: true,
add_y: true,
remove_block: true,
flip: true,
change_to_no_show: true,
change_show_full: true,
change_show_first: true,
change_show_last: true,
},

}},
watch: {
    data1: {
        handler() {
            this.make_first_last();
        },
        deep: true
    },
    checked_items: {
        handler() {
            // this.make_first_last();
            this.data1.push([0, 0, ...this.data1_template]);
            // this.test_mode === true ? this.test() : null;
        },
        deep: true
    },
},
beforeCreate(){},
created(){},
beforeMount(){},
mounted(){
    this.data1.push([0, 0, ...this.data1_template]);
    this.test_mode === true ? this.test() : null;
},
beforeUpdate(){},
updated(){},
methods: {
make_first_last(){
    this.data1.forEach((val) => {
        val[2]['first'] = val[2]['full'].slice(0, 1);
        val[2]['last'] = val[2]['full'].slice(-1);
    });
},
check_add_xy(x, y){
    // return true when there is same x,y in data1, one line fn
    return this.data1.some((val) => {
        return (val[0] === x && val[1] === y);
    });
},
make_block(IDX, x, y){
    return [IDX, 0,
        R.clone([x, y, ...this.data1_template])
    ];
},
add_x(IDX){
    // early return when there is same x,y in data1
    if(this.check_add_xy(this.data1[IDX][0]+1, this.data1[IDX][1])){
        console.log('same x,y');
        return;
    }
    // add x offset from IDX block
    this.data1.splice(
        ...this.make_block(IDX, this.data1[IDX][0]+1, this.data1[IDX][1])
    );
},
add_y(IDX){
    // early return when there is same x,y in data1
    if(this.check_add_xy(this.data1[IDX][0], this.data1[IDX][1]+1)){
        console.log('same x,y');
        return;
    }
    // add y offset from IDX block
    this.data1.splice(
        ...this.make_block(IDX, this.data1[IDX][0], this.data1[IDX][1]+1)
    );
},
check_remove_xy(x, y){
    // return true when +1x or +1y from IDX block
    return this.data1.some((val) => {
        return (val[0] === x+1 && val[1] === y) || (val[0] === x && val[1] === y+1);
    });
},
remove_block(IDX){
    // IDXのblockがx,yが0,0の場合は削除しない
    if(this.data1[IDX][0] === 0 && this.data1[IDX][1] === 0){
        console.log('0,0');
        return;
    }
    // early return when +1x or +1y from IDX block
    if(this.check_remove_xy(this.data1[IDX][0], this.data1[IDX][1])){
        console.log('+1 x,y');
        return;
    }
    this.data1.splice(IDX, 1);
},
change_to_no_show(IDX){
    this.data1[IDX][4]['no_show'] = this.data1[IDX][4]['no_show'] === true ? false : true;
},
change_to_no_show_all(){
    this.all_show_or_none = this.all_show_or_none === 'show' ? 'none' : 'show';
    this.data1.forEach((val) => {
        if(this.all_show_or_none === 'show'){
            val[4]['no_show'] = false;
        }
        if(this.all_show_or_none === 'none'){
            val[4]['no_show'] = true;
        }
    });
},
change_show_full(IDX){
    this.data1[IDX][4]['no_show'] = false;
    this.data1[IDX][2]['now'] = 'full';
},
change_show_first(IDX){
    this.data1[IDX][4]['no_show'] = false;
    this.data1[IDX][2]['now'] = 'first';
},
change_show_last(IDX){
    this.data1[IDX][4]['no_show'] = false;
    this.data1[IDX][2]['now'] = 'last';
},
flip(IDX){
    // IDXのdata1の[2]を[3]とスワップする
    this.data1[IDX][2] = [this.data1[IDX][3], this.data1[IDX][3] = this.data1[IDX][2]][0];
},
test(){
    const test_ary = [[1, 0],[2, 0],[3, 0],[4, 0],[0, 1],[0, 2],[0, 3],[0, 4],[0, 5],[3, 1],[3, 2],[3, 3],[3, 4],[3, 5],[3, 6],[4, 5],[5, 5],[5, 6],[5, 7],];
    test_ary.forEach((val) => {
        this.data1.push([val[0], val[1], ...this.data1_template]);
    });
},
checked_items_fn(){
    const checked_items_count = Object.values(this.checked_items).length;
    // checked_itemsのtrueの数からx_remを決定する(checked_itemsのtrueの数が多いほどx_remが小さくなる)
    const checked_items_true_count = Object.values(this.checked_items).filter((val) => val === true).length;
    this.x_rem = this.original_x_rem - (checked_items_count - checked_items_true_count);
},
remove_all_checked_items(){
    // checked_itemsが全てfalseであれば、全てのchecked_itemsをtrueにし、早期リターンする
    if(Object.values(this.checked_items).every((val) => val === false)){
        this.checked_items = Object.entries(this.checked_items).reduce((acc, [key, val]) => {
            acc[key] = true;
            return acc;
        }, {});
        this.checked_items_fn();
        return;
    }

    this.checked_items = Object.entries(this.checked_items).reduce((acc, [key, val]) => {
        acc[key] = false;
        return acc;
    }, {});
    this.checked_items_fn();
},



to_ary(it){
    return JSON.parse(JSON.stringify(it));
},

},
}).mount('.app');
</script>
</html>